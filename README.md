# Исследование библиотеки [CIMG](https://github.com/GreycLab/CImg) с помощью фаззера [AFL++](https://github.com/AFLplusplus/AFLplusplus.git)

## Введение 
В качестве тестирования с помощью фаззера была выбрана библиотека [CIMG](https://github.com/GreycLab/CImg). Она представляет из себя один заголовочный файл [Cimg.h](https://github.com/GreycLab/CImg/blob/master/CImg.h). 

В качестве `fuzzing target` был выбран проект из поддиректории `\example` этой библиотеки. Программа на вход принимает файлы формата `*.tiff`. В папке `testcase_dir` находится начальный корпус. Корпус - набор корректных входных данных (файлов) для программы.

Для этого исследования был выбран фаззер [AFL++](https://github.com/AFLplusplus/AFLplusplus.git). 

## Запуск фаззера

При наличии исходного кода необходимо скомпилировать программу с помощью afl-gcc, так будет добавлен инструментарий фаззера, влияющий на производительность (afl-gcc/g++/clang является как бы заменой gcc/g++/clang).

~~~
/home/ask0later/AFL__/AFL/afl-gcc [флаги] target.c -o target 
~~~

После этого запускаем фаззер при помощи:
```
./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]
```
или
```
./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@
```

Второй случай нужен для того, если программа принимает аргументы через файл.

В папке с флагом -i находится корпус - корректные входные данные.

Экран состояния фаззера:

![fuzzer](/img_for_README/fuzz.png)

## [Распараллеленный фаззинг](https://github.com/google/AFL/blob/master/docs/parallel_fuzzing.txt)

Также можно запустить несколько процессов для разных или одного target'ов при помощи следующих комманд.

В одном терминале прописываем главный (М) процесс.
```
afl-fuzz -i testcase_dir -o findings_dir -M fuzzer01 [...other stuff...]
```
В других терминалах вторичные:

```
afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 [...other stuff...]
afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 [...other stuff...]
```

## [Кастомные мутаторы](https://github.com/AFLplusplus/AFLplusplus/tree/stable/custom_mutators)

Во время выполнения фаззер мутирует входные данные (корпус) для бОльшего покрытия программы. Зная особенности формата файла `*.tiff`, можно написать свой ``mutator`` и запустить с ним фаззер. 

Чтобы определить корректность работы кастомного мутатора, будем использовать утилиту библиотеки AFL - afl-plot. Она строит график зависимости покрытия от времени командой:

~~~
afl-plot findings/default/ plot_info/
~~~

### Формат .TIFF

Структура файла с форматом .tiff состоит из:

1. Заголовка файла изображения - Image File Header (IFH).

2. Каталога файлов изображений - Image File Directory (IFD).

3. Записи в каталоге - Directory Entry (DE).

В начале файла находится header, его поля - это тег, версия файла и смещение от начала файла до первого каталога файлов изображений.

Поля IFH - это число, обозначающее общее количество записей в этом каталоге, эти самые записи, смещение от начала файла до следующего IFH.

Одна запись DE содержит в себе тег и тип атрибута, длина данных этого типа, и смещение хранилища значений атрибута.

После header и до первого IFH находится Image data, которая хранит данные изображения.

### Концепция мутации

Первоначально мутация состояла в следующем - изменить Image data.

График зависимости покрытия от времени в этом случае выглядит так:

![invalid_cust](/img_for_README/invalid_cust.png)

Покрытие не увеличивается, это скорее всего следует из того, что программа при обработке `pixel data` использует одни и те же алгоритмы (нет разницы какие цвета в картинке).

После этого было решено изменить данные структур файла (IFD, DE) на случайные числа. Этот способ также не принес результата. Понять почему так вышло, удалось только после реализации следующей мутации.

Рабочая мутация изменяла только значение аттрибутов в структуре записи DE (например, длина и высота изображения). То есть она не изменяла идентификатор атрибута. Программа могла определить по таблице атрибутов текущий, а когда были рандомные значения, скорее всего они не совпадали ни с одним, и программа пропускала их. 

Эта мутация хорошо увеличила покрытие.


### Запуск фаззера с кастомным мутатором

Файл `mutator.с` с измененными функциями компилируем в динамический разделяемый объектный файл при помощи команды:
```
gcc -shared -Wall -O3 mutator.c -o mutator.so
```
Далее при запуске фаззера в команду необходимо добавить переменную AFL_CUSTOM_MUTATOR_LIBRARY="/full/patg/to/mutator.so". Если необходимо использовать только свой кастомный фаззер, то ещё определим AFL_CUSTOM_MUTATOR_ONLY=1.


Экран состояния с использованием кастомного мутатора и встроеного:

![cust](/img_for_README/cust.png)

# Результаты
Заранее в команду была определенна переменная AFL_MAP_SIZE=65536 для того, чтобы размера bitmap был одинаковый во всех случаях.

Если сравнивать результаты тестирования фаззера с импользованием дефолтного встроеного мутатора и его же с кастомным мутатором, то видно, что кол-во `crashes` увеличилось. Эффективность тестирования возросла, это может использоваться в работе.

## Анализ покрытия

### Только дефолтный мутатор
![def_coverage](/img_for_README/def_coverage.png)

### Дефолтный и кастомный мутатор
![def_and_cust_coverage](/img_for_README/def_and_cust_coverage.png)

### Только кастомный мутатор
![cust_coverage](/img_for_README/cust_coverage.png)

Видно, что кастомная мутация может оказатся полезной, так как она вносит свой вклад в расширение покрытия программы.


## Литература
1. AFL: https://github.com/google/AFL.git.
2. AFLplusplus: https://github.com/AFLplusplus/AFLplusplus.git.
3. greybox-фаззинг: https://habr.com/ru/company/bizone/blog/570312/ и https://habr.com/ru/company/bizone/blog/570534/.
4. Detailed TIFF image file format: https://programmersought.com/article/25991320372/.